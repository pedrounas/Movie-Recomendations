---
title: "Report - Movies Recommendation in Flixster"
author: "Pedro Unas e Solange Sampaio"
date: "08/05/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introdução

O objetivo deste trabalho prático consiste em comparar diferentes métodos de recomendações para um dado cojunto de dados, de modo a fazer recomendações a um conjunto de utlizadores. Foi-nos disponiblizado os 3 seguintes ficheiros de texto pertencentes a um site de filmes, chamado Flixster:

* **Ratings.timed.txt:** Contêm os ratings que cada utilizador deu aos filmes numa respetiva data.
* **movie.txt:** Contêm o nome dos filmes e o respetivo id.
* **profile.txt:** Contêm a informação de cada utilizador (id, género, idade, localização e o tempo que é membro)


## Pré-processamento dos dados 

Ao analisar os ficheiros, reparámos que não estavam bem formatados, por isso começamos por fazer um script em python para os tratar. Para o ficheiro movie.txt, críamos duas colunas, moviename e movieid, contendo os nomes dos filmes e os id's e guardámos num ficheiro csv. O ficheiro Ratings.timed.txt também foi covertido para um ficheiro csv, contendo 4 colunas (userid, movieid, rating, date). Por fim, no ficheiro profile.txt eliminámos os valores em fata uilizando e função dropna() e covertemos este ficheiro para um ficheiro csv com 7 colunas (userid, gender, memberfor, lastlogin, profileview, age).


## Exploração dos dados 

```{r data, echo=FALSE, warning=FALSE,message=FALSE}

require(recommenderlab)
require(tidyverse)
require(reshape2)
require(ggplot2)
require(ggpubr)


set.seed(1)

data <- read.csv('Data/movie.csv')
ratings <- read.csv('Data/Ratings.csv') 
ratings.date <- ratings$date # Talvez usar isto no futuro 
ratings <- ratings %>% select(userid,movieid,rating)
```


### Número de Ratings ao longo do tempo 
 
 
```{r rating_over_time, echo=FALSE, fig.height=2.8}

ratings.date.df <- table(ratings.date) %>% as.data.frame 
ratings.date.df$ratings.date <- as.Date(ratings.date.df$ratings.date, "%Y-%m-%d")
ratings.date.df <- ratings.date.df[ratings.date.df$ratings.date >= "2005-01-01", ] # Little data before this date

ggplot(ratings.date.df, aes(x=ratings.date, y=Freq)) +
  geom_line() + 
  labs(title='Number of Ratings Over Time', x='Date', y='Frequency')
```


Ao analisar o gráfico é possível ver que houve um pico entre abril e maio do ano de 2007, o que sgnifica que havia uma grande quantidade de utilizadores ativos, havendo um decréscimo nos anos seguintes com algumas subidas não muito sigficativas. No ano 2009 houve uma subida mais acentuada no mês de maio e apartir daí houve um decréscimo muito acentuado.

### Distribuição do rating 

```{r rating_distribution, echo=FALSE, fig.height=2.8}

agg.ratings <- table(ratings$rating) %>% as.data.frame %>% rename(rating = Var1, freq = Freq)

ggplot(agg.ratings, aes(x=rating, y=freq)) + 
  geom_bar(stat = "identity") +
  labs(title='Rating Distribution', x = 'Rating', y='Frequency')
```

É possível ver que os ratings atribuídos pelos utilizadores aos filmes são na sua maioria positivos positivos, ou seja, maior que 2.5, o que podemos concluir que os utlizadores têm uma maior tendência para avaliar os filmes que mais gostaram. 

### Filmes mais populares

```{r popular_movies, echo=FALSE, fig.height=3}

  top.movies <- table(ratings$movieid) %>% as.data.frame %>% rename(movieid = Var1, freq = Freq) %>%
              merge(data, by='movieid') %>% select(moviename,freq) %>% arrange(desc(freq)) %>% head(20)
levels(top.movies$moviename) <- c(levels(top.movies$moviename), "Harry Potter and the Sorcerer's Stone")
top.movies$moviename[top.movies$moviename == "Harry Potter and the Sorcerer's Stone (Harry Potter and the Philosopher's Stone)"] <- "Harry Potter and the Sorcerer's Stone"
top.movies$moviename <- factor(top.movies$moviename, levels = top.movies$moviename[order(top.movies$freq)])

ggplot(top.movies, aes(x=moviename, y=freq)) + 
  geom_bar(stat = "identity") +
  labs(title='Most Popular Movies', x = 'Movie', y='Frequency') +
  coord_flip()

```

Como podemos observar o filme com mais avaliações é o *Transformers: Revenge of the Fallen* com cerca de 30500 avaliações. Já o segundo filme com mais popular, possuí cerca de 20250 avaliações, havendo assim uma grande diferença comparativamente com o primeiro.

### Top críticos


```{r critcs, echo=FALSE, fig.height=2.8}

best.critics <- table(ratings$userid) %>% as.data.frame %>% rename(critic = Var1, freq = Freq) %>%
                select(critic,freq) %>% arrange(desc(freq)) %>% head(20)
best.critics$critic <- factor(best.critics$critic, levels = best.critics$critic[order(best.critics$freq)])

ggplot(best.critics, aes(x=critic, y=freq)) + 
  geom_bar(stat = "identity") +
  labs(title='Top Critics', x = 'Critic', y='Frequency') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

Neste gráfico é apresentado os 20 utilizadores que avaliaram o maior número de filmes, sendo o utlizador com o id 103006 com mais de 30000 avaliações atribuídas aos filmes. 

### Top filmes 

```{r best_movie, echo=FALSE, fig.height=2.8}

best.movies <- ratings %>% select(movieid, rating) %>% group_by(movieid) %>% filter(n() > 2000) %>% 
              as.data.frame
best.movies <- aggregate(rating ~ movieid, best.movies, mean) %>% arrange(desc(rating)) %>% head(10) %>%
              merge(data, by='movieid') %>% select(moviename,rating) # Originally ≈ 1000 movies
best.movies$moviename <- factor(best.movies$moviename, levels = best.movies$moviename[order(best.movies$rating)])

ggplot(best.movies, aes(x=moviename, y=rating)) + 
  geom_bar(stat = "identity") +
  labs(title='Best Movies', x = 'Movie', y='Average Rating') +
  coord_flip(ylim = c(4.0,4.25))


```

Os 10 filmes com uma classficação maior estão apresentados neste gráfico, sendo  *Pirates of the Caribbean-. At Worlds End* o filme com melhor classificação.


## Sistemas de recomendação 

Começamos por fazer uma amostra dos dados, que contêm os id's dos utlizadores, os nomes dos filmes e o rating que deram a um determinado filme. Essa amostra contêm 3745 observações. 



Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
